# Несовпадения между комментариями и реальным кодом

Этот файл содержит найденные несовпадения между комментариями и реальным кодом в проекте.

## Просмотренные файлы и модули

### Основные файлы проекта
- `main.py` - Главный модуль для управления всеми биржами
- `api_server.py` - FastAPI сервер для работы с базой данных и предоставления API
- `config.py` - Конфигурация приложения

### Модули core/
- `core/candle_builder.py` - Универсальный построитель свечей для всех бирж
- `core/chart_generator.py` - Модуль для генерации тиковых графиков прострелов
- `core/db_error_handler.py` - Обработчик ошибок БД
- `core/health_monitor.py` - Мониторинг здоровья системы
- `core/logger.py` - Универсальная система логирования для проекта
- `core/metrics.py` - Метрики и статистика проекта
- `core/monitoring/resource_usage.py` - Мониторинг использования ресурсов
- `core/performance_timer.py` - Модуль для замера производительности этапов обработки сигналов
- `core/profiling.py` - Профилирование
- `core/spike_detector.py` - Модуль для детекта стрел (spikes) на основе фильтров пользователей
- `core/symbol_utils.py` - Модуль для нормализации символов торговых пар
- `core/telegram_notifier.py` - Модуль для отправки уведомлений в Telegram

### Модули BD/
- `BD/database.py` - Модуль для работы с базой данных SQLite (асинхронная версия с aiosqlite)
- `BD/db_utils.py` - Утилиты для работы с базой данных
- `BD/symbol_normalization_db.py` - База данных для нормализации символов

### WebSocket обработчики бирж
- `exchanges/binance/ws_handler.py` - WebSocket обработчик для Binance
- `exchanges/binance/symbol_fetcher.py` - Получение списка торговых символов с Binance API
- `exchanges/bitget/ws_handler.py` - WebSocket обработчик для Bitget
- `exchanges/bitget/symbol_fetcher.py` - Получение символов с Bitget
- `exchanges/bybit/ws_handler.py` - WebSocket обработчик для Bybit
- `exchanges/bybit/symbol_fetcher.py` - Получение символов с Bybit
- `exchanges/gate/ws_handler.py` - WebSocket обработчик для Gate.io
- `exchanges/gate/symbol_fetcher.py` - Получение символов с Gate.io
- `exchanges/hyperliquid/ws_handler.py` - WebSocket обработчик для Hyperliquid
- `exchanges/hyperliquid/symbol_fetcher.py` - Получение символов с Hyperliquid

### Веб-интерфейс (WEB/)
- `WEB/app/(dashboard)/components/SettingsTab/index.tsx` - Основной компонент настроек
- `WEB/app/api/auth/login/[user]/route.ts` - API для входа пользователя
- `WEB/app/api/auth/register/[user]/route.ts` - API для регистрации пользователя
- `WEB/app/api/users/[user]/route.ts` - API для работы с пользователями
- `WEB/app/api/users/[user]/delete/route.ts` - API для удаления пользователя
- `WEB/app/api/users/[user]/settings/route.ts` - API для настроек пользователя
- `WEB/app/api/users/[user]/test/route.ts` - API для тестирования настроек

### Документация (проверена на соответствие коду)
- `README.md` - Основная документация проекта
- `exchanges/binance/README_binance.md` - Документация по Binance
- `exchanges/bitget/README_bitget.md` - Документация по Bitget
- `exchanges/bybit/README_bybit.md` - Документация по Bybit
- `exchanges/gate/README_GATE.md` - Документация по Gate.io
- `exchanges/hyperliquid/README_hyperliquid.md` - Документация по Hyperliquid
- `BD/README.md` - Документация по базе данных

**Всего просмотрено:** ~40 файлов Python, ~10 файлов TypeScript/TSX, ~6 файлов документации

---

## 1. core/candle_builder.py

**Статус:** ✅ ИСПРАВИТЬ

### Строка 59-62
**Комментарий:**
```python
Args:
    maxlen: Максимальное количество свечей в памяти (для ограничения использования памяти)
    on_trade: Опциональный callback для подсчёта трейдов: on_trade(exchange, market)
```

**Проблема:** В комментарии не указан параметр `on_candle` и `close_timeout`, которые присутствуют в сигнатуре функции:
```python
def __init__(
    self,
    maxlen: int = 1000,
    on_trade: Optional[Callable[[str, str], Awaitable[None]]] = None,
    on_candle: Optional[Callable[[Candle], Awaitable[None]]] = None,
    close_timeout: float = 1.0,
):
```

**Строка:** 49-55

---

## 2. core/telegram_notifier.py

**Статус:** ✅ ИСПРАВИТЬ

### Строка 167-184
**Комментарий:**
```python
Args:
    token: Telegram Bot Token
    chat_id: Telegram Chat ID
    message: Текст сообщения
    
Returns:
    tuple[bool, str]: (успех, сообщение_об_ошибке)
```

**Проблема:** В комментарии не указаны параметры `max_retries` и `base_delay`, которые присутствуют в сигнатуре функции:
```python
async def send_message(
    token: str,
    chat_id: str,
    message: str,
    *,
    max_retries: int = 3,
    base_delay: float = 1.0,
) -> Tuple[bool, str]:
```

**Строка:** 167-174

---

## 3. exchanges/binance/ws_handler.py

**Статус:** ❓ ТРЕБУЕТ УТОЧНЕНИЯ

### Строка 21
**Комментарий:**
```python
FAPI_WS_ENDPOINT = "wss://fstream.binance.com/stream"  # Для combined streams (spot только)
```

**Проблема:** Комментарий говорит "spot только", но это endpoint для futures (FAPI = Futures API), а не для spot. Spot использует `SPOT_WS_ENDPOINT`.

**Строка:** 21

---

## 4. core/chart_generator.py

**Статус:** ❓ ТРЕБУЕТ УТОЧНЕНИЯ

### Строка 143-144
**Комментарий:**
```python
# Binance возвращает последние 1000 сделок, но мы можем запросить по времени
# Используем агрегированные сделки (aggTrades) для получения данных за период
```

**Проблема:** Комментарий говорит "мы можем запросить по времени", но в коде сначала устанавливается URL для обычных trades, а затем он перезаписывается на aggTrades. Логика не соответствует комментарию.

**Строка:** 143-148

---

## 5. core/spike_detector.py

**Статус:** ✅ ИСПРАВИТЬ

### Строка 386-398
**Комментарий:**
```python
"""
Проверяет, соответствует ли свеча порогам пользователя

Логика приоритета настроек:
1. Если для конкретной пары есть индивидуальные настройки в pairSettings - используем их
2. Если для конкретной пары нет индивидуальных настроек, но есть дополнительные пары для рынка - не применяем детектирование (пара отключена)
"""
```

**Проблема:** В комментарии указано "не применяем детектирование (пара отключена)", но в коде (строка 499) есть еще одна проверка: "Если нет настроек для пары и нет других пар для этого рынка - не пропускаем детект". Это противоречит логике, описанной в комментарии.

**Строка:** 386-499

---

## 6. core/telegram_notifier.py

**Статус:** ✅ ИСПРАВИТЬ

### Строка 290-323
**Комментарий:**
```python
"""
Проверяет условие для условного шаблона

Поддерживаемые типы условий:
- "volume": проверка объёма (value >= condition.value)
- "delta": проверка дельты (valueMin <= delta <= valueMax)
- "wick_pct": проверка тени (wick_pct >= valueMin)
- "series": проверка серии стрел (count >= condition.count за timeWindowSeconds)
- "symbol": проверка символа (с нормализацией)
- "exchange_market": проверка биржи и рынка
- "direction": проверка направления стрелы ("up" или "down")
"""
```

**Проблема:** В комментарии для "volume" указано `value >= condition.value`, но в коде (строка 360) используется `volume_usdt >= value`, что правильно. Однако комментарий неточен - он говорит "condition.value", а должно быть просто "value".

**Строка:** 304, 360

---

## 7. core/symbol_utils.py

**Статус:** ❓ ТРЕБУЕТ УТОЧНЕНИЯ

### Строка 246-256
**Комментарий:**
```python
"""
Получает символ в формате "BASE-QUOTE" (например, "BTC-USDT")

Args:
    symbol: Оригинальный символ (например, "BTCUSDT")
    exchange: Название биржи
    market: Тип рынка (spot/linear)
    
Returns:
    Символ в формате "BASE-QUOTE" или просто базовую монету, если не удалось определить пару
"""
```

**Проблема:** Комментарий говорит "или просто базовую монету", но в коде (строка 307) также может быть возвращен исходный символ в верхнем регистре, если не удалось определить ни базу, ни котируемую валюту.

**Строка:** 246-308

---

## 8. core/logger.py

**Статус:** ✅ ИСПРАВИТЬ

### Строка 191-198
**Комментарий:**
```python
"""
Настройка корневого логгера с поддержкой ротации логов.

Args:
    level: Уровень логирования (DEBUG, INFO, WARNING, ERROR)
    enable_file_logging: Включить запись логов в файл с ротацией
"""
```

**Проблема:** Комментарий не упоминает, что при `enable_file_logging=True` создается RotatingFileHandler с параметрами `maxBytes=10 * 1024 * 1024` (10 MB) и `backupCount=5` (5 файлов). Это важная информация, которая должна быть в документации.

**Строка:** 191-198, 227-232

---

## 9. BD/database.py

**Статус:** ✅ ИСПРАВИТЬ

### Строка 47-52
**Комментарий:**
```python
"""
Создаёт новое асинхронное подключение к БД

Returns:
    aiosqlite.Connection: Асинхронное подключение к БД
"""
```

**Проблема:** Комментарий не упоминает, что метод также инициализирует БД при первом подключении (строка 55-56), если она еще не инициализирована. Это важное поведение, которое должно быть задокументировано.

**Строка:** 47-57

---

## 10. core/metrics.py

**Статус:** ✅ ИСПРАВИТЬ

### Строка 31-52
**Комментарий:**
```python
def inc_candle(self, exchange: str, market: str = None):
    """Увеличить счётчик свечей."""
```

**Проблема:** Комментарий не описывает параметры функции и не упоминает, что для Binance сохраняется время последней свечи в формате ISO timestamp (строка 38), а для других бирж это не происходит.

**Строка:** 31-52

---

## 11. exchanges/binance/ws_handler.py

**Статус:** ❌ НЕ ИСПРАВЛЯТЬ

### Строка 27-28
**Комментарий:**
```python
# Время планового переподключения (23 часа в секундах)
SCHEDULED_RECONNECT_INTERVAL = 23 * 60 * 60  # 82800 секунд
```

**Проблема:** Комментарий говорит "23 часа", но не объясняет, почему именно 23 часа, а не 24. Это может быть связано с лимитами Binance API, но это не задокументировано.

**Строка:** 27-28

---

## 12. core/chart_generator.py

**Статус:** ✅ ИСПРАВИТЬ

### Строка 518-523
**Комментарий:**
```python
# Вычисляем период для запроса (60 минут до детекта включительно)
# candle.ts_ms - это начало секунды детекта, свеча содержит сделки от ts_ms до ts_ms + 999ms
# Поэтому запрашиваем сделки до конца секунды детекта (ts_ms + 1000ms), чтобы включить все сделки свечи
detection_time_ms = candle.ts_ms
start_time_ms = detection_time_ms - (60 * 60 * 1000)  # 60 минут назад
end_time_ms = detection_time_ms + 1000  # До конца секунды детекта включительно (ts_ms + 1000ms)
```

**Проблема:** Комментарий говорит "60 минут до детекта включительно", но в коде `end_time_ms = detection_time_ms + 1000` означает, что запрашиваются сделки до конца секунды детекта, а не до начала. Это правильно, но комментарий может быть более точным.

**Строка:** 518-523

---

## 13. core/spike_detector.py

**Статус:** ❓ ТРЕБУЕТ УТОЧНЕНИЯ

### Строка 22
**Комментарий:**
```python
self._cache_ttl = 2.5  # Кэш пользователей на 2.5 секунды для более быстрого обновления настроек
```

**Проблема:** Комментарий говорит "на 2.5 секунды", но переменная называется `_cache_ttl`, что обычно означает "time to live" в секундах. Однако в коде (строка 46) проверка `(current_time - self._cache_timestamp) < self._cache_ttl` использует разницу времени в секундах, что правильно. Комментарий корректен, но можно было бы уточнить единицы измерения.

**Строка:** 22, 46

---

## 14. core/telegram_notifier.py

**Статус:** ✅ ИСПРАВИТЬ

### Строка 61-62
**Комментарий:**
```python
# Семафор для ограничения параллельных запросов к Telegram API
# Лимит Telegram Bot API: 30 сообщений в секунду
```

**Проблема:** Комментарий говорит "30 сообщений в секунду", но в коде (строка 83) создается семафор на 30, что означает 30 параллельных запросов одновременно, а не 30 в секунду. Это разные вещи - rate limit (сообщений в секунду) и concurrency limit (параллельных запросов).

**Строка:** 61-62, 82-83

---

## 15. core/candle_builder.py

**Статус:** ✅ ИСПРАВИТЬ

### Строка 108-130
**Комментарий:**
```python
"""
Добавить сделку и получить завершённую свечу (если есть).

Args:
    exchange: Название биржи (например, "binance")
    market: "spot" или "linear"
    symbol: Название пары (например, "BTCUSDT")
    price: Цена сделки
    qty: Объём сделки в базовой валюте
    ts_ms: Timestamp сделки в миллисекундах
    
Returns:
    Candle или None, если свеча ещё не завершена
"""
```

**Проблема:** Комментарий не упоминает, что метод также вызывает callback `on_trade` (строка 132-136), если он установлен. Это важное поведение, которое должно быть задокументировано.

**Строка:** 108-136

---

## 16. core/spike_detector.py

**Статус:** ✅ ИСПРАВИТЬ

### Строка 160-169
**Комментарий:**
```python
"""
Извлекает котируемую валюту из символа

Args:
    symbol: Символ торговой пары (например, "BTCUSDT", "ETH_TRY", "LTC-TRY")
    exchange: Название биржи (binance, gate, bitget, bybit, hyperliquid)
    
Returns:
    Optional[str]: Котируемая валюта (USDT, TRY, USDC и т.д.) или None если не удалось определить
"""
```

**Проблема:** Комментарий не упоминает, что метод использует список известных котируемых валют (строка 172-175) и проверяет их в порядке убывания длины для правильного поиска. Это важная деталь реализации.

**Строка:** 160-205

---

## 17. core/telegram_notifier.py

**Статус:** ✅ ИСПРАВИТЬ

### Строка 88-104
**Комментарий:**
```python
"""
Получает ID кастомного emoji из пака через Telegram Bot API

Args:
    token: Telegram Bot Token
    emoji_name: Название emoji ("up" для зеленой стрелы вверх, "down" для красной вниз)
    
Returns:
    ID emoji или None если не удалось получить
    
Примечание:
    Для работы этого метода нужно:
    1. Добавить бота в пак emoji (https://t.me/addemoji/Strelk167)
    2. Или указать ID вручную через константы CUSTOM_EMOJI_UP_ID и CUSTOM_EMOJI_DOWN_ID
    3. ID можно получить через @BotFather или из сообщения с кастомным emoji
"""
```

**Проблема:** Комментарий говорит, что метод получает ID через Bot API, но в коде (строка 112-118) сначала проверяются глобальные константы `CUSTOM_EMOJI_UP_ID` и `CUSTOM_EMOJI_DOWN_ID`, и только если они не установлены, происходит попытка получить через Bot API. При этом код для получения через Bot API (строка 120-131) не реализован полностью - там только `pass`. Комментарий не соответствует реальной логике.

**Строка:** 88-138

---

## 18. core/chart_generator.py

**Статус:** ✅ ИСПРАВИТЬ

### Строка 189-200
**Комментарий:**
```python
"""
Получает историю сделок с Bybit через REST API

Args:
    symbol: Символ торговой пары
    market: Тип рынка (spot/linear)
    start_time: Начальное время в миллисекундах
    end_time: Конечное время в миллисекундах
    
Returns:
    Список сделок
"""
```

**Проблема:** Комментарий не упоминает, что в коде (строка 203-207) для spot и linear используется один и тот же URL `"https://api.bybit.com/v5/market/recent-trade"`, а различие только в параметре `category`. Также не упоминается, что символ может быть преобразован (строка 210-212), если он не заканчивается на USDT или USDC.

**Строка:** 189-254

---

## 19. core/spike_detector.py

**Статус:** ✅ ИСПРАВИТЬ

### Строка 249-262
**Комментарий:**
```python
"""
Вычисляет объём в USDT

Args:
    candle: Свеча
    
Returns:
    float: Объём в USDT (используем close * volume как приближение)
"""
```

**Проблема:** Комментарий говорит "используем close * volume как приближение", но в коде (строка 261) используется `candle.volume * candle.close`, что математически то же самое, но порядок умножения может иметь значение для понимания. Также комментарий не упоминает, что `candle.volume` уже в базовой валюте (строка 259).

**Строка:** 249-262

---

## 20. core/performance_timer.py

**Статус:** ✅ ИСПРАВИТЬ

### Строка 63-69
**Комментарий:**
```python
"""
Форматирует метрики для отправки в Telegram.

Returns:
    Отформатированная строка с метриками
"""
```

**Проблема:** Комментарий не упоминает, что метод также вычисляет общее время (строка 108-113) и добавляет его в конец строки. Также не упоминается порядок этапов для отображения (строка 77-85).

**Строка:** 63-115

---

## 21. exchanges/gate/ws_handler.py

**Статус:** ✅ ИСПРАВИТЬ

### Строка 69-78
**Комментарий:**
```python
"""
WebSocket worker для одного соединения.
"""
```

**Проблема:** Комментарий очень краткий и не описывает параметры функции и её поведение. В функции есть сложная логика переподключения, обработки ошибок, отправки ping, но это не задокументировано.

**Строка:** 69-75

---

## 22. exchanges/bybit/ws_handler.py

**Статус:** ✅ ИСПРАВИТЬ

### Строка 48-59
**Комментарий:**
```python
"""
WebSocket consumer для одного соединения с несколькими батчами внутри.
"""
```

**Проблема:** Комментарий не описывает параметры функции, особенно важные параметры `batches` (список кортежей) и логику работы с батчами. Также не упоминается, что функция подписывается на каждый батч отдельно из-за лимита Bybit (строка 93-98).

**Строка:** 48-56

---

## 23. exchanges/bitget/ws_handler.py

**Статус:** ✅ ИСПРАВИТЬ

### Строка 72-81
**Комментарий:**
```python
"""
WebSocket worker для одного батча символов.
"""
```

**Проблема:** Комментарий не описывает параметры функции, особенно `batch_id` и логику работы с первым сообщением для каждого символа (строка 83, 94-95). Также не упоминается, что при реконнекте очищается словарь `first_message_for_symbol`.

**Строка:** 72-78

---

## 24. exchanges/hyperliquid/ws_handler.py

**Статус:** ✅ ИСПРАВИТЬ

### Строка 76-86
**Комментарий:**
```python
"""
Проверяет и применяет rate limiting для сообщений.
Удаляет старые timestamps (старше 1 минуты) и ждёт, если лимит превышен.

Использует цикл для повторной проверки лимита после ожидания, чтобы предотвратить
превышение лимита, когда несколько корутин одновременно ждут и просыпаются.

Args:
    is_ping: Если True, ping сообщения обходят rate limiting (критично для соединения)
"""
```

**Проблема:** Комментарий говорит "ping сообщения обходят rate limiting", но в коде (строка 90-99) ping сообщения НЕ учитываются в rate limit, но всё равно очищают старые timestamps. Это правильно, но комментарий можно было бы уточнить.

**Строка:** 76-100

---

## 25. exchanges/bitget/ws_handler.py

**Статус:** ✅ ИСПРАВИТЬ

### Строка 64-69
**Комментарий:**
```python
def _safe_float(x) -> float:
    """Безопасное преобразование в float."""
```

**Проблема:** Комментарий не упоминает, что при ошибке возвращается `math.nan` (строка 69), а не `0.0` как в других файлах (например, в `exchanges/gate/ws_handler.py` строка 58). Это важное отличие, которое должно быть задокументировано.

**Строка:** 64-69

---

## 26. core/spike_detector.py

**Статус:** ✅ ИСПРАВИТЬ

### Строка 316-329
**Комментарий:**
```python
"""
Проверяет, соответствует ли свеча условию биржи в стратегии

Args:
    strategy: Словарь стратегии с полями:
        - conditions: List[Dict] - список условий
    candle: Свеча для проверки
    
Returns:
    Tuple[bool, bool]: (соответствует_ли_условию, есть_ли_условие_биржа)
        - Первое значение: True если свеча соответствует условию биржи (или условие не указано)
        - Второе значение: True если в стратегии есть условие биржи (exchange или exchange_market)
"""
```

**Проблема:** Комментарий не упоминает, что функция проверяет два типа условий: `exchange` и `exchange_market`, причем `exchange_market` имеет приоритет (строка 348). Также не упоминается нормализация рынка (строка 356-373), где "futures" и "linear" считаются одинаковыми.

**Строка:** 316-384

---

## 27. core/telegram_notifier.py

**Статус:** ✅ ИСПРАВИТЬ

### Строка 141-165
**Комментарий:**
```python
"""
Форматирует кастомное emoji или возвращает fallback

Логика работы:
1. Сначала пытается использовать кастомное emoji из пака Strelk167
2. Если кастомное emoji недоступно (ID пустой или пак не установлен у получателя),
   Telegram автоматически покажет fallback emoji (⬆️/⬇️)

Args:
    emoji_id: ID кастомного emoji из пака Strelk167
    fallback_emoji: Стандартный emoji для fallback (⬆️ или ⬇️)
    
Returns:
    Отформатированная строка с кастомным emoji (если доступно) или fallback
"""
```

**Проблема:** Комментарий говорит "Telegram автоматически покажет fallback emoji", но в коде (строка 161) используется формат `<tg-emoji emoji-id="{emoji_id}">{fallback_emoji}</tg-emoji>`, где fallback emoji указывается внутри тега. Это означает, что Telegram сначала попытается показать кастомное emoji, а если не получится - покажет fallback. Комментарий правильный, но можно было бы уточнить формат.

**Строка:** 141-164

---

## 28. core/chart_generator.py

**Статус:** ✅ ИСПРАВИТЬ

### Строка 123-135
**Комментарий:**
```python
"""
Получает историю сделок с Binance через REST API

Args:
    symbol: Символ торговой пары (например, BTCUSDT)
    market: Тип рынка (spot/linear)
    start_time: Начальное время в миллисекундах
    end_time: Конечное время в миллисекундах
    
Returns:
    Список сделок
"""
```

**Проблема:** Комментарий не упоминает, что функция использует `aggTrades` endpoint (строка 146-148), а не обычные trades, и преобразует формат данных (строка 162-177). Также не упоминается, что возвращается максимум 1000 сделок (строка 154).

**Строка:** 123-186

---

## 29. core/symbol_utils.py

**Статус:** ✅ ИСПРАВИТЬ

### Строка 28-39
**Комментарий:**
```python
"""
Алгоритмическая нормализация символа (извлечение базовой монеты)

Args:
    symbol: Оригинальный символ (например, BTCUSDT, ETH_USDT, BTC/USDC)
    exchange: Название биржи
    market: Тип рынка (spot/linear)
    
Returns:
    Нормализованный символ (базовая монета) или None если не удалось определить
"""
```

**Проблема:** Комментарий не упоминает специальную обработку для Hyperliquid (строка 52-86), где для linear рынка символы уже нормализованы, а для spot может быть два формата: с разделителем "/" или слитный формат.

**Строка:** 28-89

---

## 30. BD/database.py

**Статус:** ✅ ИСПРАВИТЬ

### Строка 70-78
**Комментарий:**
```python
"""Инициализирует БД: создаёт все таблицы, если их нет"""
```

**Проблема:** Комментарий очень краткий и не упоминает, что функция также выполняет миграции (строка 96-113), включая добавление полей, удаление таблиц и автоматическую миграцию данных (строка 144-220). Это важная функциональность, которая должна быть задокументирована.

**Строка:** 70-220

---

## Резюме

Найдено 30 несовпадений между комментариями и реальным кодом:
- Отсутствующие параметры в документации функций
- Неточные описания логики работы
- Неполная документация важных деталей реализации
- Противоречия между комментариями и кодом
- Отсутствие упоминаний о побочных эффектах (callbacks, инициализация)
- Неописанные специальные случаи обработки (Hyperliquid, миграции БД)
- Неточные описания форматов данных и преобразований

### Статистика по статусам:
- ✅ **ИСПРАВИТЬ:** 25 пунктов
- ❌ **НЕ ИСПРАВЛЯТЬ:** 1 пункт (пункт 11)
- ❓ **ТРЕБУЕТ УТОЧНЕНИЯ:** 4 пункта (пункты 3, 4, 7, 13)

Рекомендуется обновить документацию для всех пунктов со статусом "ИСПРАВИТЬ".

