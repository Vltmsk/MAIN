# Дерево логики проекта: от получения свечи до отправки сигнала

## Общая схема потока данных

```
Биржа (WebSocket) 
  ↓
Получение данных (сделки/свечи)
  ↓
Построение 1-секундных свечей (CandleBuilder)
  ↓
Детектирование прострелов (SpikeDetector)
  ↓
Сохранение в БД (Database)
  ↓
Формирование сообщения (TelegramNotifier)
  ↓
Генерация графика (ChartGenerator, опционально)
  ↓
Отправка в Telegram (TelegramNotifier)
```

---

## 1. Получение данных от биржи

### 1.1. Инициализация подключений
**Файл:** `exchanges/{exchange}/ws_handler.py`

- **Запуск биржи** (`start()`):
  - Проверка конфигурации (включен ли spot/linear)
  - Получение списка символов через `symbol_fetcher.py`
  - Создание WebSocket соединений (разбиение на чанки по лимитам биржи)
  - Запуск worker'ов для каждого соединения

- **Создание сессии** (`aiohttp.ClientSession`):
  - Настройка SSL контекста
  - Подключение к WebSocket endpoint биржи

### 1.2. Обработка WebSocket сообщений
**Файл:** `exchanges/{exchange}/ws_handler.py` → `_ws_connection_worker()`

- **Получение данных:**
  - Для Binance: готовые 1-секундные свечи через `kline_1s` стримы
  - Для других бирж: сделки (trades) через trade стримы

- **Обработка ошибок:**
  - Переподключение с экспоненциальной задержкой
  - Плановое переподключение каждые 23 часа
  - Логирование ошибок через `on_error` callback

### 1.3. Парсинг данных
**Файл:** `exchanges/{exchange}/ws_handler.py` → `_handle_kline_message()` / обработка trades

- **Для Binance:**
  - Парсинг `kline` сообщений
  - Извлечение: open, high, low, close, volume, timestamp
  - Создание объекта `Candle`

- **Для других бирж:**
  - Парсинг trade сообщений
  - Передача в `CandleBuilder.add_trade()`

---

## 2. Построение 1-секундных свечей

### 2.1. CandleBuilder
**Файл:** `core/candle_builder.py`

- **Инициализация:**
  - Создание словаря активных свечей: `{(exchange, market, symbol): CurrentCandle}`
  - Настройка таймеров принудительного закрытия

- **Обработка сделок** (`add_trade()`):
  - Округление timestamp до начала секунды
  - Определение ключа: `(exchange, market, symbol)`
  - Если сделка относится к новой секунде:
    - Завершение предыдущей свечи
    - Создание новой активной свечи
  - Добавление сделки в текущую свечу:
    - Обновление open (первая сделка)
    - Обновление high/low (максимум/минимум)
    - Обновление close (последняя сделка)
    - Накопление volume

- **Принудительное закрытие свечей:**
  - Таймер на 1 секунду после последней сделки
  - Если нет новых сделок → закрытие свечи
  - Вызов `on_candle` callback с завершённой свечой

### 2.2. Структура свечи (Candle)
**Файл:** `core/candle_builder.py`

```python
Candle(
    ts_ms: int,      # Timestamp в миллисекундах
    open: float,     # Цена открытия
    high: float,     # Максимальная цена
    low: float,      # Минимальная цена
    close: float,    # Цена закрытия
    volume: float,   # Объём в базовой валюте
    market: str,     # "spot" или "linear"
    exchange: str,   # Название биржи
    symbol: str      # Название пары
)
```

---

## 3. Детектирование прострелов

### 3.1. Главный обработчик свечей
**Файл:** `main.py` → `on_candle()`

- **Получение завершённой свечи:**
  - Вызов из `CandleBuilder` или напрямую от Binance
  - Обновление метрик (счётчик свечей)

- **Запуск детектирования:**
  - Вызов `spike_detector.detect_spike(candle)`
  - Параллельная обработка для всех пользователей

### 3.2. SpikeDetector
**Файл:** `core/spike_detector.py`

#### 3.2.1. Получение пользователей
- **Кэширование** (TTL = 2.5 секунды):
  - Загрузка всех пользователей из БД
  - Кэш обновляется автоматически

#### 3.2.2. Параллельная проверка для каждого пользователя
**Метод:** `_check_user_spike()`

**Шаг 1: Вычисление метрик свечи**
- `delta` = максимальное отклонение от open (в процентах)
- `wick_pct` = процент тени (верхняя + нижняя тень)
- `volume_usdt` = объём в USDT (volume * close)

**Шаг 2: Проверка обычных настроек прострела**
- Проверка включения биржи (`_check_exchange_filter()`):
  - Формат: `{exchange}_{market}` (например, `binance_spot`)
  - Обратная совместимость: только биржа
- Проверка фильтров (`_check_thresholds()`):
  - Приоритет: индивидуальные настройки пары (`pairSettings`)
  - Ключ: `{exchange}_{market}_{quote_currency}` (например, `binance_spot_USDT`)
  - Проверка порогов:
    - `delta > delta_min` (строго больше)
    - `volume_usdt > volume_min` (строго больше)
    - `wick_pct >= wick_pct_min` (больше или равно)
  - Если есть другие пары для рынка, но нет настроек для текущей → детектирование не применяется

**Шаг 3: Проверка стратегий** (`conditionalTemplates`)
- Для каждой стратегии:
  - Проверка `enabled` (включена ли стратегия)
  - Получение базовых фильтров:
    - Если `useGlobalFilters = true` → используем фильтры из `pairSettings`
    - Если `useGlobalFilters = false` → используем фильтры из условий стратегии
  - Проверка базовых фильтров (delta, volume, wick_pct)
  - Проверка условия биржи (`exchange` / `exchange_market`):
    - Если биржа указана в стратегии → автоматическое включение (даже если отключена в exchanges)
  - Проверка всех условий стратегии (`_check_strategy_conditions()`):
    - `series`: проверка серии стрел за временное окно
    - `symbol`: проверка символа (с нормализацией)
    - `direction`: проверка направления (up/down)
    - `market`: проверка типа рынка
    - И другие условия...

**Шаг 4: Добавление в трекер серий**
- Если стрела детектирована → добавление в `_series_tracker`
- Ключ: `{user_id}_{exchange}_{market}_{symbol}`
- Хранение: список последних стрел с параметрами
- Очистка старых данных (TTL на основе максимального `timeWindowSeconds` из стратегий)

#### 3.2.3. Проверка серий стрел
**Метод:** `_get_series_count()`

- Получение количества стрел за временное окно
- Фильтрация по условиям стратегии (delta, volume, wick_pct, direction, symbol, exchange, market)
- Используется для условия `series` в стратегиях

### 3.3. Результат детектирования
**Возвращает:** `List[Dict]` с информацией о детектированных стрелах:
```python
{
    "user_id": int,
    "user_name": str,
    "delta": float,
    "wick_pct": float,
    "volume_usdt": float,
    "detected_by_spike_settings": bool,
    "detected_by_strategy": bool,
    "matched_strategies": List[Dict]  # Список сработавших стратегий
}
```

---

## 4. Сохранение в базу данных

### 4.1. Сохранение стрелы
**Файл:** `main.py` → `on_candle()` → для каждого пользователя

- **Сохранение в таблицу `alerts`:**
  - `ts` (timestamp в миллисекундах)
  - `exchange`, `market`, `symbol`
  - `delta`, `wick_pct`, `volume_usdt`
  - `meta` (JSON с флагами детектирования и списком стратегий)
  - Уникальность: `(ts, exchange, market, symbol, delta, wick_pct, volume_usdt)`

- **Сохранение связи с пользователем:**
  - Таблица `user_alerts`: `(user_id, alert_id)`

### 4.2. Database
**Файл:** `BD/database.py`

- Асинхронная работа с SQLite через `aiosqlite`
- WAL режим для конкурентных записей
- Обработка ошибок (IntegrityError для дубликатов)

---

## 5. Формирование сообщения

### 5.1. Получение настроек пользователя
**Файл:** `main.py` → `on_candle()`

- Получение данных пользователя из БД
- Парсинг `options_json`:
  - `messageTemplate` (дефолтный шаблон)
  - `conditionalTemplates` (стратегии)
  - `timezone` (временная зона)
  - `pairSettings` (настройки отправки графиков)

### 5.2. Выбор шаблона
**Файл:** `core/telegram_notifier.py` → `format_spike_messages()`

- **Приоритет:**
  1. Если детектировано через стратегию → используем шаблоны стратегий
  2. Если детектировано через обычные настройки → используем дефолтный шаблон

- **Выбор условных шаблонов** (`_select_templates()`):
  - Проверка всех условий для каждого шаблона
  - Если все условия выполнены → шаблон добавляется в список
  - Если нет подходящих → используется дефолтный шаблон

### 5.3. Форматирование сообщения
**Файл:** `core/telegram_notifier.py` → `format_spike_messages()`

- **Вычисление значений:**
  - Форматирование времени в указанной временной зоне
  - Определение направления (up/down) с кастомными emoji
  - Форматирование чисел (delta, volume, wick_pct)
  - Получение символа с торговой парой (например, "BTC-USDT")

- **Замена плейсхолдеров:**
  - `{delta_formatted}` → "5.23%"
  - `{volume_formatted}` → "1.5M$"
  - `{wick_formatted}` → "45.2%"
  - `{direction}` → кастомное emoji (⬆️/⬇️)
  - `{exchange_market}` → "BINANCE | SPOT"
  - `{symbol}` → "BTC-USDT"
  - `{time}` → "2024-01-15 12:30:45"
  - И другие...

- **Результат:** список сообщений с `chatId` для каждого шаблона

---

## 6. Генерация графика (опционально)

### 6.1. Проверка настройки отправки графиков
**Файл:** `main.py` → `on_candle()`

- Проверка `pairSettings[{exchange}_{market}_{quote_currency}].sendChart`
- Если `true` → запуск генерации графика

### 6.2. ChartGenerator
**Файл:** `core/chart_generator.py`

- **Кэширование графиков:**
  - Ключ: `{exchange}_{market}_{symbol}_{detection_timestamp}`
  - TTL: 10 минут

- **Генерация графика** (`generate_chart()`):
  1. Проверка кэша
  2. Запрос истории сделок с биржи (REST API):
     - Период: 60 минут до детекта включительно
     - Получение тиковых данных
  3. Построение графика с matplotlib:
     - Тиковый график (каждая сделка)
     - Выделение детектированной свечи
     - Подписи: биржа, рынок, символ, время
     - Сохранение в PNG (BytesIO)
  4. Сохранение в кэш
  5. Возврат байтов изображения

---

## 7. Отправка в Telegram

### 7.1. Отправка графика с текстом
**Файл:** `main.py` → `_send_chart_async()`

- **Генерация графика:**
  - Вызов `chart_generator.generate_chart()`
  - Получение байтов изображения

- **Отправка фото:**
  - Вызов `telegram_notifier.send_photo()`
  - `caption` = текст сообщения (обрезка до 1024 символов)
  - Rate limiting через семафор (30 запросов/секунду)

- **Fallback при ошибке:**
  - Если не удалось отправить график → отправка текстового сообщения

### 7.2. Отправка текстового сообщения
**Файл:** `main.py` → `_send_text_message_async()`

- Вызов `telegram_notifier.send_message()`
- Rate limiting через семафор
- Retry логика (3 попытки с экспоненциальной задержкой)

### 7.3. TelegramNotifier
**Файл:** `core/telegram_notifier.py`

- **Отправка сообщения** (`send_message()`):
  - POST запрос к Telegram Bot API
  - Обработка ошибок (таймауты, сетевые ошибки)
  - Retry с экспоненциальной задержкой

- **Отправка фото** (`send_photo()`):
  - POST запрос с FormData
  - Включение caption с HTML разметкой
  - Обработка ошибок и retry

### 7.4. Отправка метрик производительности (опционально)
**Файл:** `main.py` → `_send_performance_metrics_to_user()`

- Если у пользователя включены метрики (`metrics_enabled`)
- Создание `PerformanceTimer` для замера времени операций:
  - `db.get_user` - получение данных пользователя
  - `db.save` - сохранение в БД
  - `format.message` - форматирование сообщения
  - `chart.generate` - генерация графика
  - `tg.send` - отправка в Telegram
- Отправка сводки метрик после успешной отправки сигнала

---

## Дополнительные компоненты

### Мониторинг и метрики
- **Metrics** (`core/metrics.py`):
  - Счётчик свечей по биржам и рынкам
  - Счётчик трейдов (ticks)
  - Расчёт T/s (свечей или трейдов в секунду)

- **Health Monitor** (`core/health_monitor.py`):
  - Мониторинг здоровья системы
  - Отслеживание ресурсов

### Логирование
- **Logger** (`core/logger.py`):
  - Ротация логов
  - Запись в файлы и консоль
  - Логирование ошибок в БД

### Нормализация символов
- **Symbol Utils** (`core/symbol_utils.py`):
  - Нормализация символов между биржами
  - Кэширование в БД нормализации
  - Получение символа с торговой парой

---

## Параллелизм и асинхронность

- **Параллельная обработка пользователей:**
  - `asyncio.gather()` для проверки всех пользователей одновременно
  - Независимая обработка каждого пользователя

- **Асинхронная отправка уведомлений:**
  - `asyncio.create_task()` для отправки в фоне
  - Не блокирует основной поток детектирования

- **Rate limiting:**
  - Семафор на 30 параллельных запросов к Telegram API
  - Предотвращение превышения лимитов API

---

## Обработка ошибок

- **На уровне биржи:**
  - Автоматическое переподключение
  - Логирование ошибок через `on_error` callback

- **На уровне детектирования:**
  - Обработка ошибок для каждого пользователя отдельно
  - Продолжение работы при ошибке у одного пользователя

- **На уровне отправки:**
  - Retry логика (3 попытки)
  - Fallback на текстовое сообщение при ошибке графика
  - Логирование всех ошибок

---

## Кэширование

- **Кэш пользователей:**
  - TTL: 2.5 секунды
  - Автоматическое обновление

- **Кэш графиков:**
  - TTL: 10 минут
  - Ключ включает timestamp детекта

- **Кэш нормализации символов:**
  - Хранение в БД нормализации
  - Постоянное кэширование

---

## Заключение

Проект реализует полный цикл от получения данных с биржи до отправки уведомлений пользователям:

1. **Сбор данных** - WebSocket подключения к биржам
2. **Обработка данных** - построение свечей из сделок
3. **Анализ** - детектирование прострелов по фильтрам и стратегиям
4. **Хранение** - сохранение в БД для истории
5. **Уведомление** - формирование и отправка сообщений в Telegram

Все компоненты работают асинхронно и параллельно для максимальной производительности.

