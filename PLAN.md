# Глобальный план развития проекта

## Улучшения функциональности

## Технические улучшения

### 9. Реализация независимых стратегий детектирования (бывшие "условные форматы сообщений")
**Статус:** Не реализовано (все еще используются условные форматы сообщений)

**Проблема:** 
- Условные форматы сообщений работают только для уже детектированных стрел, что создаёт конфликты с настройками прострела
- Пользователь не может настроить независимую стратегию детектирования с более сложными условиями (серия стрел, конкретная монета, биржа и так далее)
- Нет возможности использовать разные фильтры для разных стратегий

**Задача:**
Реализовать независимую систему стратегий детектирования, которая работает параллельно с обычными настройками прострела.

**Основные требования:**

1. **Переименование и реорганизация интерфейса:**
   - Переименовать блок "Условные форматы сообщений" в "Стратегии"
   - Вынести "Стратегии" в подменю вверху рядом с "Формат отправки детекта"
   - Обновить все текстовые надписи и описания

2. **Независимое детектирование:**
   - Стратегии должны детектировать стрелы независимо от настроек прострела (exchangeSettings, pairSettings, thresholds)
   - Обе системы работают параллельно и независимо
   - Если стрела проходит обе системы - приоритет у стратегии (отправляется шаблон стратегии, не дефолтный), об этом можно сделать уведомление где-то пользователю, не навязчивое, в подсказке где-то может быть.

3. **Логика детектирования:**
   - **Обычные настройки прострела:** работают как раньше (exchangeSettings, pairSettings, thresholds)
   - **Стратегии:** детектируют стрелы по своим фильтрам:
     - Базовые фильтры: delta, volume, wick_pct
     - Дополнительные условия: series, symbol, exchange, market, direction
     - **Расширяемость:** Код должен быть готов к добавлению новых условий разработчиком без изменения основной логики
   - Если стрела детектирована только через обычный прострел → отправляется дефолтный шаблон (messageTemplate)
   - Если стрела детектирована только через стратегию → отправляется шаблон стратегии
   - Если стрела детектирована через обе системы → отправляется шаблон стратегии (приоритет)

4. **Базовые фильтры в стратегиях:**
   - По умолчанию: галочка "Использовать мои фильтры из глобальных настроек (дельта, объём, тень)"
   - Если галочка включена: используются фильтры из exchangeSettings/pairSettings/thresholds для данной биржи/рынка/пары
   - Если галочка выключена: появляются 3 обязательных поля:
     - Дельта (обязательно)
     - Объём (обязательно)
     - Тень (обязательно)
   - Дополнительные фильтры (series, symbol, exchange, market) всегда доступны независимо от галочки
   - **Валидация:** При сохранении стратегии проверять:
     - Если `useGlobalFilters = false` и отсутствуют базовые фильтры (delta, volume, wick_pct) → показывать ошибку:
       - Текст: "Стратегия не может работать без базовых фильтров. Пожалуйста, либо включите 'Использовать мои фильтры из глобальных настроек', либо укажите значения для Дельта, Объём и Тень в условиях стратегии."
       - Подсветить поля, которые нужно заполнить
       - Не позволять сохранить стратегию до исправления

5. **Проверка биржи:**
   - Если биржа отключена в `exchanges`, но указана в стратегии → автоматически включить эту биржу **только для данной стратегии**
   - **Важно:** Биржа включается только для параметров стратегии, а для фильтров глобальных настроек должна оставаться отключенной, если пользователь сам вручную её не включил во вкладке "настройки прострелов"
   - Стратегия работает только для указанных в ней бирж/рынков, но если пользователь не добавил в условия бирж/рынки, то стратегия работает для всех активных `exchanges`

6. **Трекер серий стрел:**
   - Обновлять трекер серий для всех детектированных стрел (и через обычный прострел, и через стратегии)
   - **Важно:** Каждая стрела учитывается в трекере только один раз (уникальность по `{exchange}_{market}_{symbol}_{timestamp}`)
   - При проверке условия "series" в стратегии:
     - Учитывать все стрелы из трекера (и через обычный прострел, и через стратегии)
     - Фильтровать только те стрелы, которые соответствуют **всем** условиям этой стратегии (delta, volume, wick_pct, direction, symbol, exchange, market из условий стратегии)
     - **Важно:** При фильтрации использовать те же фильтры, что и для детектирования (если `useGlobalFilters = true` → фильтры из глобальных настроек, если `useGlobalFilters = false` → фильтры из условий стратегии)
     - Каждая стратегия считает серию по своим условиям независимо
   - Временное окно: если указано "серия ≥ 2 стрелы за 5 минут", считать только стрелы, детектированные за последние 5 минут от момента текущей стрелы
   - **Хранение в памяти:** Хранить в памяти только стрелы за максимальный период времени, указанный в стратегиях пользователя
     - По умолчанию: 15 минут (900 секунд)
     - Если у какого-то пользователя выставлена серия стрел со временем больше 15 минут → использовать максимальное значение из всех стратегий
     - Старые стрелы автоматически удаляются из памяти

7. **Логика отправки при серии стрел:**
   - **При каждой новой стреле:**
     - Проверяем все условия стратегии (включая условие "series")
     - Смотрим назад на N времени (timeWindowSeconds) от момента текущей стрелы
     - Если за это время было достаточно стрел (≥ count), которые соответствуют условиям стратегии → отправляем сигнал
     - **Важно:** Ограничения частоты нет - отправляем при каждой новой стреле, если все условия выполнены
   - **Пример:**
     - Условие: серия ≥ 2 стрелы за 5 минут, delta ≥ 0.3%, volume ≥ 1млн$
     - T0: 1-я стрела (delta=0.5%, volume=1.5млн$) → смотрим назад 5 минут от T0 → серия = 1, не отправляем
     - T1 (через 1 мин): 2-я стрела (delta=0.4%, volume=1.2млн$) → смотрим назад 5 минут от T1 → серия = 2, все условия выполнены → отправляем
     - T2 (через 2 мин от T1): 3-я стрела (delta=0.6%, volume=1.8млн$) → смотрим назад 5 минут от T2 → серия = 3, все условия выполнены → отправляем
     - T3 (через 3 мин от T2): 4-я стрела (delta=0.3%, volume=1.1млн$) → смотрим назад 5 минут от T3 → серия = 4, все условия выполнены → отправляем

8. **Сохранение в БД:**
   - Сохранять все детектированные стрелы (и через обычный прострел, и через стратегии)
   - Добавить флаги в результат детектирования: `detected_by_spike_settings`, `detected_by_strategy`
   - В трекере серий хранить информацию о том, через что детектирована стрела (для отладки)
   - **Важно:** Стрела не может считаться дубликатом, если это 2 стрелы для разных пользователей
   - **Уникальность:** Каждая стрела уникальна по комбинации `{user_id}_{exchange}_{market}_{symbol}_{timestamp}` - одна и та же свеча может быть детектирована для разных пользователей независимо

9. **Множественные стратегии:**
   - Если стрела проходит несколько стратегий → отправлять все подходящие шаблоны
   - Каждая стратегия проверяется независимо
   - Каждая стратегия считает свою серию независимо
   - **Важно:** Пользователь должен иметь возможность создавать сколько угодно стратегий, все проверки должны быть параллельными и не задерживать друг друга
   - **Ограничение:** Рекомендуется ограничить количество активных стратегий на пользователя (например, до 50) для предотвращения проблем с производительностью

**Технические требования:**

1. **Изменения в `core/spike_detector.py`:**
   - **КРИТИЧЕСКИ ВАЖНО: Рефакторинг `detect_spike()` для параллельной обработки пользователей**
     - Текущая проблема: метод `detect_spike()` синхронный и обрабатывает пользователей последовательно, что приводит к задержкам для последних пользователей
     - Решение: преобразовать `detect_spike()` в асинхронный метод и использовать `asyncio.gather()` для параллельной проверки всех пользователей одновременно
     - Каждый пользователь проверяется в отдельной задаче (task), все задачи выполняются параллельно
     - **Цель:** Все пользователи должны быть в равных условиях и получать детекты максимально быстро (практически одновременно, разница < 100ms)
     - Ошибка обработки одного пользователя не должна блокировать или замедлять обработку других
   - Модифицировать метод `detect_spike()` для проверки стратегий независимо от обычных настроек
   - Добавить метод `_check_strategy_conditions()` для проверки условий стратегии
     - **Расширяемость:** Метод должен использовать общий механизм проверки условий (например, вызов `telegram_notifier._check_condition()` или аналогичный паттерн), чтобы новые условия автоматически поддерживались без изменения логики детектирования
   - Добавить метод `_extract_strategy_filters()` для извлечения фильтров из стратегии
   - Добавить метод `_check_user_spike()` для проверки одного пользователя (используется в параллельной обработке)
   - Обновить трекер серий:
     - Убедиться, что каждая стрела учитывается только один раз (проверка уникальности по `{exchange}_{market}_{symbol}_{timestamp}`)
     - При проверке серий фильтровать по условиям стратегии (все условия, включая delta, volume, wick_pct, direction, symbol, exchange, market)
     - Добавить информацию о том, через что детектирована стрела (для отладки)
     - Хранить в памяти только стрелы за максимальный период времени из всех стратегий пользователя
     - Индексировать трекер по времени для быстрого поиска
   - При проверке условия "series":
     - Смотреть назад на N времени (timeWindowSeconds) от момента текущей стрелы
     - Считать только стрелы, которые соответствуют **всем** условиям стратегии (delta, volume, wick_pct, direction, symbol, exchange, market и т.д.)
   - **Производительность:**
     - Все проверки должны быть параллельными для разных пользователей (через `asyncio.gather()`)
     - Один пользователь не должен ждать проверки условий другого
     - Оптимизировать порядок проверок: сначала быстрые фильтры (включение биржи, базовые условия), затем сложные (серии)

2. **Изменения в `core/telegram_notifier.py`:**
   - Метод `_check_condition()` уже поддерживает все типы условий: volume, delta, wick_pct, series, symbol, exchange, market, direction
   - Метод `_select_templates()` уже поддерживает множественные шаблоны
   - Убедиться, что проверка условий стратегии работает корректно
   - **Расширяемость:** Метод `_check_condition()` должен использовать паттерн, позволяющий легко добавлять новые типы условий (например, через словарь обработчиков или match/case)

3. **Изменения в `main.py`:**
   - В функции `on_candle()`:
     - Вызывать асинхронный метод `detect_spike()` (после рефакторинга)
     - Проверять детектирование через обычные настройки
     - Проверять детектирование через стратегии
     - Если детектирована через стратегию → отправлять шаблон стратегии
     - Если детектирована только через обычный прострел → отправлять дефолтный шаблон
     - Сохранять в БД все детектированные стрелы
   - **Важно:** 
     - Обработка должна быть максимально быстрой, чтобы пользователь получал детект максимально быстро
     - Все пользователи должны получать детекты практически одновременно (благодаря параллельной обработке в `detect_spike()`)
     - При проблемах с Telegram API для одного пользователя не должно блокироваться отправка для других пользователей

4. **Изменения в интерфейсе (`WEB/app/(dashboard)/components/SettingsTab.tsx`):**
   - Переименовать блок "Условные форматы сообщений" в "Стратегии"
   - Вынести в подменю рядом с "Формат отправки детекта"
   - Добавить галочку "Использовать мои фильтры из глобальных настроек"
   - При снятии галочки показывать 3 обязательных поля: Дельта, Объём, Тень
   - Добавить валидацию при сохранении:
     - Если `useGlobalFilters = false` и отсутствуют базовые фильтры → показывать ошибку
     - Подсветить поля, которые нужно заполнить
     - Не позволять сохранить стратегию до исправления
   - Добавить подсказки и примеры для помощи пользователю
   - Обновить все текстовые надписи и описания

5. **Структура данных стратегии:**
   ```json
   {
     "name": "Название стратегии",
     "description": "Описание",
     "enabled": true,
     "useGlobalFilters": true,  // Новая галочка
     "conditions": [
       {
         "type": "delta",
         "valueMin": 0.3,
         "valueMax": null
       },
       {
         "type": "volume",
         "value": 1000000
       },
       {
         "type": "wick_pct",
         "valueMin": 0,
         "valueMax": null
       },
       {
         "type": "series",
         "count": 2,
         "timeWindowSeconds": 300
       },
       {
         "type": "symbol",
         "symbol": "ZEC"
       },
       {
         "type": "exchange",
         "exchange": "binance"
       },
      {
        "type": "market",
        "market": "spot"
      },
      {
        "type": "direction",
        "direction": "up"  // или "down"
      }
    ],
    "template": "Шаблон сообщения",
    "chatId": "Опциональный Chat ID"
  }
  ```

**Логика работы:**

1. **Детектирование:**
   ```
   Свеча → detect_spike()
     ├─→ Проверка обычных настроек прострела (параллельно для всех пользователей)
     │   └─→ Если проходит → детектируем (флаг: detected_by_spike_settings)
     │
     └─→ Проверка стратегий (независимо, параллельно для всех пользователей)
         └─→ Для каждой стратегии:
             ├─→ Если useGlobalFilters = true → используем фильтры из exchangeSettings/pairSettings/thresholds
             ├─→ Если useGlobalFilters = false → используем фильтры из условий стратегии
             ├─→ Проверяем дополнительные условия (series, symbol, exchange, market)
             └─→ Если проходит → детектируем (флаг: detected_by_strategy)
   ```

2. **Отправка уведомлений:**
   ```
   Если detected_by_strategy:
     └─→ Отправляем шаблон стратегии (приоритет)
   Иначе если detected_by_spike_settings:
     └─→ Отправляем дефолтный шаблон (messageTemplate)
   ```

3. **Трекер серий:**
   ```
   Для всех детектированных стрел:
     └─→ Проверяем уникальность (exchange_market_symbol_timestamp)
     └─→ Если уникальна → добавляем в трекер
     └─→ Сохраняем информацию о том, через что детектирована
     └─→ Удаляем стрелы старше максимального периода времени из всех стратегий
   
   При проверке условия "series" в стратегии:
     └─→ Получаем все стрелы за временное окно (timeWindowSeconds назад от текущей стрелы)
     └─→ Фильтруем только те, что соответствуют **всем** условиям этой стратегии (delta, volume, wick_pct, direction, symbol, exchange, market и т.д.)
     └─→ Считаем количество
     └─→ Если количество ≥ count → условие выполнено
   ```

**Потенциальные проблемы и решения:**

1. **Производительность:**
   - **Проблема:** Двойная проверка каждой свечи (обычные настройки + стратегии). При последовательной обработке пользователей последний пользователь получит сигнал позже первого, что создаёт неравные условия для пользователей
   - **Решение:** 
     - **КРИТИЧЕСКИ ВАЖНО: Рефакторинг `detect_spike()` для параллельной обработки**
       - Преобразовать `detect_spike()` из синхронного метода в асинхронный
       - Использовать `asyncio.gather()` для параллельной проверки всех пользователей одновременно
       - Каждый пользователь проверяется в отдельной задаче (task), все задачи выполняются параллельно
       - Ошибка обработки одного пользователя не должна блокировать или замедлять обработку других
       - **Цель:** Все пользователи должны быть в равных условиях и получать детекты максимально быстро (практически одновременно, разница < 100ms)
     - Оптимизировать порядок проверок - сначала быстрые фильтры (включение биржи, базовые условия), затем сложные (серии)
     - Каждый пользователь проверяется независимо и параллельно с другими
     - **Важно:** Все пользователи должны получить сигнал практически одновременно (разница только в сетевых задержках при отправке в Telegram, но не в детектировании)
   - **Примечание:** Отправка в Telegram должна быть асинхронной и не блокировать детектирование для других пользователей

2. **Память:**
   - **Проблема:** Рост трекера серий при большом количестве пользователей
   - **Решение:** Хранить в памяти только стрелы за максимальный период времени из всех стратегий пользователя (по умолчанию 15 минут). Старые стрелы автоматически удаляются

3. **Валидация стратегий:**
   - **Проблема:** Пользователь может создать неработающую стратегию
   - **Решение:** Валидация при сохранении, подсказки и примеры в интерфейсе, статистика по стратегиям в UI (опционально)

4. **Безопасность:**
   - **Проблема:** Валидация условий стратегии, доступ к настройкам других пользователей
   - **Решение:** 
     - Валидация всех входных данных с ограничениями диапазонов значений:
       - Дельта: от 0.01% до 100%
       - Объём: от 1 USDT до 1,000,000,000 USDT
       - Тень: от 0% до 100%
       - Серия: от 1 до 100 стрел
       - Временное окно: от 1 секунды до 3600 секунд (1 час)
       - Направление: только "up" или "down"
     - Проверка прав доступа в API, фильтрация по user_id во всех запросах

5. **Telegram API лимиты:**
   - **Проблема:** Множественные отправки могут превысить лимиты Telegram API
   - **Решение:** 
     - Отслеживать лимиты Telegram API (см. README.md раздел "Лимиты Telegram Bot API")
     - При превышении лимитов отправлять уведомление пользователю в Telegram
     - При проблемах с Telegram API для одного пользователя не блокировать отправку для других
   - **Лимиты Telegram Bot API:**
     - **Групповые чаты:** 20 сообщений в секунду на чат
     - **Личные чаты:** 30 сообщений в секунду на чат
     - **Глобальный лимит:** 30 сообщений в секунду на бота
     - При превышении лимита Telegram возвращает ошибку 429 (Too Many Requests) с временем ожидания в заголовке `Retry-After`

6. **Изменение глобальных фильтров:**
   - **Проблема:** Если глобальные фильтры изменятся, стратегии с `useGlobalFilters = true` начнут работать по-другому
   - **Решение:** При изменении глобальных фильтров показывать предупреждение о влиянии на стратегии

7. **Расширяемость кода для новых условий:**
   - **Проблема:** При добавлении нового типа условия (например, "time_of_day", "volatility") нужно изменять код в нескольких местах
   - **Решение:** 
     - Использовать единый механизм проверки условий (например, словарь обработчиков или match/case в `_check_condition()`)
     - Метод `_check_strategy_conditions()` в `spike_detector.py` должен использовать тот же механизм, что и `telegram_notifier._check_condition()`
     - Документировать процесс добавления новых условий для разработчиков
     - Новые условия должны автоматически работать в стратегиях без изменения основной логики детектирования

**Обратная совместимость:**
- Проект в процессе разработки, у пользователей ещё нет стратегий
- Существующие условные форматы (`conditionalTemplates`) должны работать как стратегии
- Если в стратегии нет поля `useGlobalFilters` → считать его `true` (использовать глобальные фильтры)
- Если в стратегии нет базовых фильтров (delta, volume, wick_pct) и `useGlobalFilters = false` → показывать ошибку валидации
- Миграция: при загрузке существующих `conditionalTemplates` автоматически устанавливать `useGlobalFilters = true`
- **Важно:** Старые условные шаблоны продолжают работать как раньше (детектируются только после прохождения обычных фильтров), но после реализации стратегий они будут работать независимо

**Технические детали реализации:**

1. **Параллельная обработка пользователей (КРИТИЧЕСКИ ВАЖНО):**
   - **Проблема:** Текущий метод `detect_spike()` синхронный и обрабатывает пользователей последовательно, что создаёт неравные условия - последние пользователи получают сигнал позже первых
   - **Решение:**
     - Преобразовать `detect_spike()` в асинхронный метод: `async def detect_spike(self, candle: Candle) -> List[Dict]`
     - Создать вспомогательный метод `async def _check_user_spike(self, user: Dict, candle: Candle) -> Optional[Dict]` для проверки одного пользователя
     - В `detect_spike()` использовать `asyncio.gather()` для параллельной обработки:
       ```python
       users = self._get_users()
       tasks = [self._check_user_spike(user, candle) for user in users]
       results = await asyncio.gather(*tasks, return_exceptions=True)
       detected_spikes = [r for r in results if r is not None and not isinstance(r, Exception)]
       ```
     - Обработка ошибок: `return_exceptions=True` гарантирует, что ошибка одного пользователя не блокирует других
     - **Цель:** Все пользователи получают детекты практически одновременно (разница < 100ms), все в равных условиях
   - Обновить вызов в `main.py`: `detected_spikes = await spike_detector.detect_spike(candle)`

2. **Структура данных стратегий:**
   - Сохранять в `conditionalTemplates` (переименовывать в интерфейсе, но в БД оставить для совместимости)
   - Добавить поле `useGlobalFilters: boolean` (по умолчанию `true`)
   - При `useGlobalFilters = false` валидировать наличие условий `delta`, `volume`, `wick_pct` в массиве `conditions`

3. **Логика детектирования:**
   - Проверка стратегий происходит в `detect_spike()` параллельно с обычными настройками
   - Использовать `asyncio.gather()` для параллельной обработки всех пользователей (см. пункт 1)
   - Возвращать флаги: `detected_by_spike_settings`, `detected_by_strategy`, `matched_strategies` (список ID стратегий)

4. **Базовые фильтры:**
   - При `useGlobalFilters = true`: использовать фильтры из `exchangeSettings/pairSettings/thresholds`
   - При `useGlobalFilters = false`: извлекать фильтры из условий стратегии (обязательны delta, volume, wick_pct)
   - Валидация на frontend и backend: если `useGlobalFilters = false` и нет базовых фильтров → ошибка

5. **Автоматическое включение биржи:**
   - Если биржа указана в условии стратегии (через условие `exchange` или `exchange_market`), но отключена в `exchanges` → временно игнорировать проверку `_check_exchange_filter()` только для этой стратегии
   - **Важно:** Биржа включается только для проверки условий стратегии, глобальные фильтры (exchangeSettings/pairSettings/thresholds) остаются отключенными для этой биржи
   - Если в стратегии не указана конкретная биржа в условиях, стратегия работает только для бирж, включенных в `exchanges`

6. **Трекер серий:**
   - Уникальность по `{exchange}_{market}_{symbol}_{candle.ts_ms}` (использовать timestamp из свечи в миллисекундах)
   - **Важно:** Использовать `candle.ts_ms` для уникальности, а не `time.time()`, чтобы избежать дубликатов при одновременной обработке
   - Хранить информацию о способе детектирования (опционально, для отладки)
   - Автоматическая очистка: максимальный период из всех стратегий пользователя (по умолчанию 15 минут)

7. **Проверка условия "series":**
   - При проверке серии использовать фильтры из условий стратегии (если `useGlobalFilters = false`) или из глобальных настроек (если `useGlobalFilters = true`)
   - Фильтровать стрелы по **всем** условиям стратегии (delta, volume, wick_pct, direction, symbol, exchange, market)
   - Временное окно: смотреть назад на `timeWindowSeconds` от момента текущей стрелы

8. **Расширяемость:**
   - Рефакторинг `_check_condition()` в словарь обработчиков:
     ```python
     CONDITION_HANDLERS = {
         "volume": _check_volume_condition,
         "delta": _check_delta_condition,
         "wick_pct": _check_wick_pct_condition,
         "series": _check_series_condition,
         "symbol": _check_symbol_condition,
         "exchange_market": _check_exchange_market_condition,
         "direction": _check_direction_condition,
     }
     ```
   - `_check_strategy_conditions()` в `spike_detector.py` использует тот же механизм

9. **Валидация на backend:**
   - В API endpoint `WEB/app/api/users/[user]/settings/route.ts` при сохранении стратегии
   - Диапазоны: delta (0.01%-100%), volume (1-1,000,000,000 USDT), wick_pct (0%-100%), серия (1-100), временное окно (1-3600 сек)
   - Проверка прав доступа, фильтрация по user_id

**Места изменений:**
- `core/spike_detector.py` - модификация `detect_spike()`, добавление методов проверки стратегий, обновление трекера серий
- `main.py` - обновление логики в `on_candle()` (вызов асинхронного `detect_spike()`, обработка флагов детектирования)
- `WEB/app/(dashboard)/components/SettingsTab.tsx` - реорганизация интерфейса, добавление галочки, валидация, подсказки
- `core/telegram_notifier.py` - проверка корректности работы с условиями (уже поддерживается)
- `WEB/app/api/users/[user]/settings/route.ts` - валидация стратегий на backend (диапазоны значений, проверка базовых фильтров)

**Приоритет:** Высокий

**Разбивка на этапы:**

Этап 1: Реорганизация интерфейса
- [x] Вынести "Стратегии" в подменю рядом с "Формат отправки детекта" (добавлена кнопка в подменю)
- [x] Удалена карточка "Условные форматы сообщений" из вкладки "format"
- [x] Переименовать "Условные форматы сообщений" в "Стратегии" (создана вкладка "strategies" с полным интерфейсом)
- [x] Обновить все текстовые надписи и описания в новой вкладке "strategies" (все переименовано: "Шаблон" → "Стратегия", "Включен" → "Включена", "Сохранить условные шаблоны" → "Сохранить стратегии")

Этап 2: Структура данных и обратная совместимость
-  Добавить поле `useGlobalFilters` в структуру данных стратегии (frontend)
-  Реализовать обратную совместимость (по умолчанию `true`, если поле отсутствует)
-  Обновить код загрузки стратегий для обработки `useGlobalFilters`
-  Обновить код сохранения стратегий для отправки `useGlobalFilters`
-  Установить `useGlobalFilters: true` по умолчанию при создании новых стратегий

Этап 3: UI для базовых фильтров
-  Добавить галочку "Использовать мои фильтры из глобальных настроек"
-  Реализовать условное отображение полей Дельта/Объём/Тень при снятии галочки
-  Добавить подсказки и примеры для помощи пользователю

Этап 4: Валидация стратегий
-  Реализовать валидацию при сохранении стратегии
-  Проверка наличия базовых фильтров при `useGlobalFilters=false`
-  Подсветка полей с ошибками, блокировка сохранения до исправления

Этап 5: Методы проверки стратегий в spike_detector.py
-  Добавить метод `_extract_strategy_filters()` для извлечения фильтров из стратегии
-  Добавить метод `_check_strategy_conditions()` для проверки условий стратегии
-  **Расширяемость:** Использовать единый механизм проверки условий (например, вызов `telegram_notifier._check_condition()`), чтобы новые условия автоматически поддерживались

Этап 6: Независимое детектирование
- Модифицировать `detect_spike()` для независимой проверки стратегий
- Параллельная работа с обычными настройками прострела
- Добавить флаги `detected_by_spike_settings` и `detected_by_strategy`

Этап 7: Обновление трекера серий
- Уникальность стрел по `{exchange}_{market}_{symbol}_{timestamp}`
- Хранение информации о способе детектирования (для отладки)
- Автоматическая очистка старых стрел (максимальный период из всех стратегий)
- Индексирование по времени для быстрого поиска

Этап 8: Логика проверки условия "series"
- Реализовать временное окно (timeWindowSeconds назад от текущей стрелы)
- Фильтрация стрел по **всем** условиям стратегии (delta, volume, wick_pct, direction, symbol, exchange, market и т.д.)
- Независимый подсчет серии для каждой стратегии
- Отправка при каждой новой стреле, если все условия выполнены

Этап 9: Интеграция в main.py
- Обновить функцию `on_candle()` для проверки стратегий
- Реализовать приоритет отправки (шаблон стратегии > дефолтный шаблон)
- Сохранять все детектированные стрелы в БД с флагами
- Обеспечить быструю обработку, не блокировать отправку для других пользователей

Этап 10: Автоматическое включение биржи для стратегии
- Если биржа отключена в `exchanges`, но указана в стратегии → включить только для параметров стратегии
- Глобальные фильтры должны оставаться отключенными, если пользователь не включил биржу вручную

Этап 11: Валидация входных данных на backend
- Диапазоны значений: delta (0.01%-100%), volume (1-1,000,000,000 USDT), wick_pct (0%-100%)
- Серия: от 1 до 100 стрел
- Временное окно: от 1 секунды до 3600 секунд (1 час)
- Направление: только "up" или "down"
- Проверка прав доступа в API, фильтрация по user_id

Этап 12: Оптимизация производительности и параллельность (КРИТИЧЕСКИ ВАЖНО)
- **Рефакторинг `detect_spike()` для параллельной обработки пользователей:**
  - Преобразовать метод `detect_spike()` из синхронного в асинхронный (`async def detect_spike()`)
  - Создать вспомогательный метод `_check_user_spike()` для проверки одного пользователя
  - Использовать `asyncio.gather()` для параллельной проверки всех пользователей одновременно
  - Каждый пользователь обрабатывается в отдельной задаче (task), все задачи выполняются параллельно
  - Обработка ошибок: ошибка одного пользователя не должна блокировать или замедлять обработку других
- Параллельная обработка всех пользователей одновременно (не последовательно)
- Оптимизация порядка проверок (быстрые фильтры сначала, затем сложные)
- **Цель:** Все пользователи должны быть в равных условиях и получать детекты максимально быстро (практически одновременно, разница < 100ms)
- Обновить вызов `detect_spike()` в `main.py` на асинхронный вызов с `await`

Этап 13: Множественные стратегии
- Отправка всех подходящих шаблонов, если стрела проходит несколько стратегий
- Независимая проверка каждой стратегии
- Независимый подсчет серии для каждой стратегии

Этап 14: Обеспечение расширяемости кода
- Рефакторинг `_check_condition()` в `telegram_notifier.py` для использования единого механизма (словарь обработчиков)
- Убедиться, что `_check_strategy_conditions()` в `spike_detector.py` использует тот же механизм
- Документировать процесс добавления новых условий для разработчиков
- Протестировать, что новые условия автоматически работают в стратегиях без изменения основной логики



---

## Важные замечания и уточнения

### Критические моменты для реализации:

1. **Порядок проверок в `detect_spike()`:**
   - Сначала проверяем обычные настройки прострела (быстро)
   - Затем проверяем стратегии (может быть медленнее из-за проверки серий)
   - Обе проверки выполняются параллельно для всех пользователей через `asyncio.gather()`

2. **Уникальность стрел:**
   - Использовать `candle.ts_ms` (timestamp свечи в миллисекундах) для уникальности
   - Формат ключа: `{user_id}_{exchange}_{market}_{symbol}_{candle.ts_ms}`
   - Это гарантирует, что одна и та же свеча может быть детектирована для разных пользователей независимо

3. **Логика приоритета отправки:**
   - Если стрела детектирована через стратегию → отправляем шаблон стратегии (даже если она также прошла обычные фильтры)
   - Если стрела детектирована только через обычные фильтры → отправляем дефолтный шаблон
   - Если стрела прошла несколько стратегий → отправляем все подходящие шаблоны стратегий

4. **Проверка условия "series":**
   - При проверке серии учитывать все условия стратегии (не только delta и volume, но и direction, symbol, exchange, market)
   - Использовать те же фильтры, что и для детектирования (глобальные или из условий стратегии, в зависимости от `useGlobalFilters`)

5. **Производительность:**
   - Все проверки пользователей должны быть параллельными (через `asyncio.gather()`)
   - Отправка в Telegram не должна блокировать детектирование для других пользователей
   - Трекер серий должен быть оптимизирован для быстрого поиска (индексирование по времени)

6. **Валидация:**
   - Frontend: валидация при сохранении стратегии (проверка базовых фильтров при `useGlobalFilters = false`)
   - Backend: валидация диапазонов значений и проверка прав доступа
   - Обе валидации должны работать независимо и дублировать друг друга для безопасности

---
---

