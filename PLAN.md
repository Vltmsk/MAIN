# Глобальный план развития проекта

## Критически важные задачи

(Все задачи выполнены)

---

## Критические исправления

(Все задачи выполнены)

---

## Улучшения функциональности

### 5. Добавление опциональной отправки тиковых графиков прострелов вместе с сигналами
**Проблема:** Пользователи хотят видеть визуальное представление движения цены перед детектом прострела, но не для всех пар и не всегда.

**Задача:** 
- Добавить возможность выбора для пользователя - присылать ли тиковый график прострела вместе с сигналом или нет
- Создать отдельный небольшой блок после блока "условные форматы сообщений" в настройках
- В этом блоке реализовать настройку в виде галочек или тумблеров вкл/выкл для каждой торговой пары
- Если пользователь включает отправку графиков для конкретной торговой пары (например, Binance Spot USDC), ему будут присылаться графики только для детектов с этой торговой парой
- Для остальных пар (с выключенным тумблером) будут отправляться только текстовые детекты без графиков
- График должен показывать движение цены минимум за 30-60 минут до момента детекта
- График должен отображать тиковые данные (scatter plot) с цветовой индикацией (зеленые/красные точки для роста/падения)
- График должен включать метрики в заголовке: Exchange | Market, Symbol, изменение цены, объем, Spike Ratio, Duration, Strategy, Score
- График должен визуально выделять момент прострела (стрелка или выделение области)

**Технические требования:**
- Графики не должны тормозить отправку детектов - текстовое сообщение должно отправляться немедленно, график генерируется и отправляется асинхронно
- Реализовать кэширование графиков: если несколько пользователей поймали детект на одну и ту же монету и пару, использовать один и тот же график для всех (не генерировать отдельно для каждого пользователя)
- Ключ кэша: `{exchange}_{market}_{symbol}_{timestamp_detection}` с временем жизни кэша (например, 5-10 минут после детекта)
- Хранение настройки отправки графиков в `options_json` пользователя:
  - Для индивидуальных пар: `pairSettings["{exchange}_{market}_{quoteCurrency}"]["sendChart"]: boolean`
  - Для глобальных настроек: `exchangeSettings["{exchange}"]["{market}"]["sendChart"]: boolean`
- Если генерация графика не удалась - отправлять только текстовое сообщение, логировать ошибку

**Технические детали (уточнено):**
- **Формат графика:** PNG
- **Библиотека для генерации:** matplotlib (рекомендуется) - простая, быстрая, хорошо работает с scatter plots, легковесная
  - Альтернативы: plotly (более интерактивная, но тяжелее) или PIL/Pillow (низкоуровневая, сложнее)
- **Источник данных:** Запрос истории сделок через REST API биржи за последние 30 минут (рекомендуется)
  - Причины: не нужно хранить огромное количество тиков в памяти постоянно, тики нужны только при детекте
  - Альтернатива: хранить тики в памяти (занимает много памяти, но быстрее)
- **Период отображения:** 30 минут до момента детекта
- **Разрешение:** 1920x1080 пикселей
- **Способ отправки:** Как фото через Telegram Bot API метод sendPhoto

**Структура настроек:**
Настройка отправки графиков хранится в `options_json` пользователя в том же месте, где хранятся настройки пар:
- Для индивидуальных пар: `pairSettings["binance_spot_USDC"]["sendChart"]: true`
- Для глобальных настроек биржи/рынка: `exchangeSettings["binance"]["spot"]["sendChart"]: true`
- **По умолчанию:** `sendChart = false` (графики отключены для всех новых пользователей)
- Если флаг `sendChart` не указан или `false` - график не отправляется, только текстовое сообщение

**Приоритет:** Высокий

---

### 8. Исправление проблем с отправкой графика вместе с текстом
**Проблема:** При отправке графика с текстом как подписью (caption) существует несколько потенциальных проблем, которые могут привести к потере уведомлений или некорректной работе системы.

**Задача:** Исправить следующие проблемы:

1. **Отсутствие fallback при ошибке генерации графика**
   - Если график не сгенерируется (`chart_bytes = None`), пользователь не получает уведомление вообще
   - Решение: При ошибке генерации графика отправлять текстовое сообщение как fallback

2. **Множественные графики для одного события**
   - Если есть несколько условных шаблонов, отправляется несколько графиков с одинаковым содержимым
   - Решение: Кэшировать график и отправлять один график с разными подписями или объединять сообщения

3. **Ошибки при отправке без уведомления пользователя**
   - Если отправка графика не удастся, пользователь не получает уведомление
   - Решение: При ошибке отправки графика отправлять текстовое сообщение

4. **Дублирование генерации графиков**
   - Если несколько пользователей имеют одинаковые условия для одной свечи, график генерируется для каждого (хотя есть кэш на 10 минут)
   - Решение: Оптимизировать - генерировать график один раз и переиспользовать для всех пользователей

**Технические требования:**
- Добавить fallback механизм: при ошибке генерации или отправки графика отправлять текстовое сообщение
- Оптимизировать логику отправки: если есть несколько условных шаблонов, использовать один график с разными подписями
- Улучшить обработку ошибок: логировать все ошибки и гарантировать доставку уведомления пользователю
- Оптимизировать генерацию: использовать кэш более эффективно для множественных пользователей

**Места изменений:**
- `main.py` - функция `_send_chart_async` (добавить fallback на текстовое сообщение)
- `main.py` - логика отправки в `on_candle` (оптимизировать для множественных шаблонов)
- `core/chart_generator.py` - возможно улучшение кэширования

**Приоритет:** Средний

---

## Улучшения интерфейса

### 1. Улучшение подсказок (tooltips)
**Проблема:** Подсказки возле названий блоков повторяют описания блоков.

**Задача:** 
- Сделать подсказки более подробными и информативными
- Отличать подсказки от основных описаний блоков
- При наведении мышкой показывать дополнительную полезную информацию

**Приоритет:** Низкий

---

### 6. Рефакторинг блока "Фильтры по биржам" в настройках
**Проблема:** 
- В блоке "Фильтры по биржам" во вкладке настройки отсутствует возможность настройки каждой торговой пары отдельно
- Сейчас всего 5 секций (одна биржа = одна секция с подсекциями Spot/Futures), а должно быть 10 секций (каждая биржа разделена на Spot и Futures)
- Для некоторых бирж нужно сразу открывать дополнительные пары без блока с полями "Дельта %", "Объём USDT", "Тень %" (который сейчас показывается до нажатия "Открыть дополнительные пары")
- Для остальных бирж должна быть подпись конкретной торговой пары вместо "Все торговые пары"
- При отключении торговой пары она должна скрываться, при включении - раскрываться

**Текущая структура бирж и пар:**
- **Binance Spot:** 12 торговых пар
- **Binance Futures:** 3 торговые пары
- **Bybit Spot:** 5 торговых пар
- **Bybit Futures:** 1 торговая пара "USDT"
- **Bitget Spot:** 1 торговая пара "USDT"
- **Bitget Futures:** 1 торговая пара "USDT"
- **Gate Spot:** 1 торговая пара "USDT"
- **Gate Futures:** 1 торговая пара "USDT"
- **Hyperliquid Spot:** 1 торговая пара "USDC"
- **Hyperliquid Futures:** 1 торговая пара "USDC"

**Задача:**
- Разделить текущие 5 секций на 10 отдельных секций (каждая биржа отдельно для Spot и Futures):
  - Binance Spot (отдельная секция)
  - Binance Futures (отдельная секция)
  - Bybit Spot (отдельная секция)
  - Bybit Futures (отдельная секция)
  - Bitget Spot (отдельная секция)
  - Bitget Futures (отдельная секция)
  - Gate Spot (отдельная секция)
  - Gate Futures (отдельная секция)
  - Hyperliquid Spot (отдельная секция)
  - Hyperliquid Futures (отдельная секция)
- Для **Binance Spot**, **Binance Futures** и **Bybit Spot** - при открытии секции сразу показывать список всех дополнительных пар (12 для Binance Spot, 3 для Binance Futures, 5 для Bybit Spot) без блока с полями "Дельта %", "Объём USDT", "Тень %" (который сейчас показывается до нажатия "Открыть дополнительные пары")
- Для остальных бирж (Bybit Futures, Bitget Spot/Futures, Gate Spot/Futures, Hyperliquid Spot/Futures) - вместо "Все торговые пары" показывать конкретную торгую пару в заголовке (например, "USDT" для Bybit Futures, "USDC" для Hyperliquid Spot)
- При отключении переключателя конкретной торговой пары (например, TRY в Binance Spot) - карточка пары должна скрываться из интерфейса
- При включении переключателя торговой пары - карточка пары должна раскрываться и показываться в интерфейсе

**Технические требования:**
- Рефакторинг структуры компонента `DashboardShell.tsx` для разделения секций
- Обновление логики отображения пар в зависимости от состояния переключателя (скрытие/показ карточек пар)
- Обновление структуры данных для хранения настроек (если необходимо)
- Сохранение обратной совместимости с существующими настройками пользователей
- В проекте нет глобальных настроек - каждая торговая пара имеет свои индивидуальные настройки

**Приоритет:** Высокий

---

## Технические улучшения

### 2. Настройка перезапуска после деплоя
**Задача:** Настроить систему так, чтобы `main.py` не перезапускался на сервере после получения обновлений с GitHub, а остальные компоненты перезапускались.

**Приоритет:** Средний

---

### 3. Добавление принудительного переподключения WebSocket каждые 23 часа
**Проблема:** В настоящее время WebSocket соединения переподключаются только при ошибках или разрыве соединения. Долгие соединения могут терять актуальность данных или иметь проблемы с таймаутами на стороне биржи.

**Задача:** 
- Добавить отслеживание времени начала каждого WebSocket соединения
- Реализовать принудительное переподключение всех WebSocket соединений раз в 23 часа (82800 секунд)
- Применить это для всех бирж: Gate, Binance, Bitget, Bybit, Hyperliquid
- Обеспечить плавное переподключение без потери данных
- **Важно:** Плановые переподключения раз в 23 часа не должны учитываться в счетчике переподключений (reconnects), так как это плановое техническое обслуживание, а не ошибка

**Приоритет:** Средний

---

### 7. Оптимизация производительности страницы статистики через нормализацию символов при записи в БД
**Проблема:** Когда в статистике по пользователям накапливается больше 1 тысячи свечей, страница со статистикой очень долго открывается. Причина: при каждом запросе статистики происходит нормализация символов для всех записей (каждая запись обрабатывается отдельно через `normalize_symbol`), что создает значительную нагрузку на систему при большом количестве данных.

**Задача:** 
- Нормализовать символы торговых пар **перед записью** в базу данных, а не при чтении
- Изменить метод `add_alert` в `BD/database.py` для нормализации символа перед записью
- Убрать нормализацию символов из API статистики (`api_server.py`), так как символы уже будут нормализованы в БД
- Обеспечить обратную совместимость с существующими данными в БД

**Технические требования:**
- **Изменение метода `add_alert` в `BD/database.py`:**
  - Добавить вызов `normalize_symbol` перед записью в БД
  - Использовать нормализованный символ при проверке существующих записей (поиск дубликатов)
  - Использовать нормализованный символ при создании новых записей
  - Импортировать `normalize_symbol` из `core.symbol_utils`
  
- **Изменение API статистики в `api_server.py`:**
  - Убрать все вызовы `normalize_symbol` при обработке статистики
  - Использовать символы напрямую из БД (они уже нормализованы)
  - Это касается следующих мест:
    - Топ символов (группировка по символам)
    - Последние 20 стрел для таблицы
    - Топ 10 стрел по дельте
    - Топ 10 стрел по объёму

- **Обратная совместимость:**
  - Для существующих записей в БД с ненормализованными символами:
    - **Вариант А (рекомендуется):** Создать скрипт миграции для нормализации всех существующих символов в таблице `alerts`
    - **Вариант Б:** Временно оставить нормализацию при чтении для старых записей (проверять, нормализован ли символ, и нормализовать при необходимости)
  - Рекомендуется использовать вариант А для полной оптимизации

- **Миграция данных (опционально, но рекомендуется):**
  - Создать скрипт миграции, который:
    - Читает все записи из таблицы `alerts`
    - Нормализует символы для каждой записи
    - Обновляет записи в БД с нормализованными символами
    - Обрабатывает возможные дубликаты (если одна и та же стрела была записана с разными форматами символа)

**Преимущества:**
- **Производительность:** Нормализация выполняется один раз при записи, а не при каждом чтении
- **Скорость статистики:** Не нужно нормализовать тысячи символов при каждом запросе статистики
- **Агрегация в SQL:** Можно использовать группировку по символам напрямую в SQL-запросах БД
- **Консистентность:** Все символы в БД будут в нормализованном виде

**Технические детали:**
- Функция `normalize_symbol` из `core/symbol_utils.py` уже существует и работает асинхронно
- Нормализация извлекает базовую монету из символа (например, "BTCUSDT" → "BTC")
- Нормализация учитывает особенности разных бирж (Binance, Gate, Bitget, Bybit, Hyperliquid)
- Нормализация использует БД нормализации символов для кэширования результатов

**Места изменений:**
- `BD/database.py` - метод `add_alert` (добавить нормализацию перед записью)
- `api_server.py` - функция `get_user_spikes_stats` (убрать нормализацию при чтении)
- `main.py` - вызов `db.add_alert` (не требует изменений, нормализация будет внутри метода)

**Приоритет:** Высокий

---

## Контент и тексты

### 4. Проверка и исправление текстовых надписей
**Задача:** 
- Проверить все текстовые надписи в проекте
- Внести логические изменения и исправления
- Улучшить формулировки для лучшего понимания

**Приоритет:** Низкий

---

## Статус выполнения

- [ ] 1. Улучшение подсказок (tooltips)
- [ ] 2. Настройка перезапуска после деплоя
- [ ] 3. Добавление принудительного переподключения WebSocket каждые 23 часа
- [ ] 4. Проверка и исправление текстовых надписей
- [ ] 5. Добавление опциональной отправки тиковых графиков прострелов вместе с сигналами
- [ ] 6. Рефакторинг блока "Фильтры по биржам" в настройках
- [ ] 7. Оптимизация производительности страницы статистики через нормализацию символов при записи в БД
- [ ] 8. Исправление проблем с отправкой графика вместе с текстом

---

## Тестовые сценарии для проверки

### Проверка работы условных форматов сообщений на дополнительных парах

**Сценарий:**

1. **Настройки профиля:**
   - На Binance Spot для пары TRY настроены фильтры:
     - Дельта: 2%
     - Объем: 500000 USDT
     - Тень: 50%

2. **Условный формат сообщения:**
   - Серия стрел: 3 шт за 300 секунд
   - Дельта: от 0.4% до бесконечности
   - Объем: 65000 USDT

3. **Событие:**
   - На паре TRY-ETH происходит 5 палок подряд в течение 5 минут
   - Дельта: 0.5%
   - Объем: 50000 USDT
   - Тень свечи: больше 50%

**Вопрос для проверки:**
Должен ли дополнительный условный формат сообщения поймать детект в такой ситуации на паре TRY-ETH?

**Ожидаемое поведение:**
- Условный формат сообщения должен сработать, если:
  - Количество стрел (5) >= требуемого (3)
  - Временной интервал (5 минут = 300 секунд) <= требуемого (300 секунд)
  - Дельта (0.5%) >= минимальной (0.4%)
  - Объем (50000 USDT) < требуемого (65000 USDT) — **НЕ соответствует условию**
- Если объем не соответствует условию, детект не должен сработать

**Требуется проверить:**
- Корректность работы условных форматов сообщений на дополнительных парах (TRY-ETH)
- Применение условий по объему, дельте, количеству стрел и времени
- Логику проверки всех условий условного формата сообщения

---

*Последнее обновление: 2024*

